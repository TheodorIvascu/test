name: Auto Label Test Cases

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

jobs:
  test-case-labeling:
    runs-on: ubuntu-latest
    steps:
      - name: Apply dynamic labels based on test case form
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || "";
            const currentLabels = issue.labels.map(label => label.name);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = issue.number;

            let labelsToAdd = [];
            let labelsToRemove = [];

            // Helper to extract dropdown value from markdown
            function getDropdownValue(label) {
              const regex = new RegExp(`${label}\s*\n(.*?)\n`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            }

            // Updated Helper to detect checkbox status including emojis like ✅
            function isCheckboxChecked(label) {
              const regex = new RegExp(`(- \[x\]|✅|☑️)\s*${label}`, 'i');
              return regex.test(body);
            }

            // Type of Testing labels
            const testingTypeMap = {
              "Navigation": "Navigation",
              "Content Testing": "Content Testing",
              "GUI and Usability": "GUI and Usability",
              "Performance Testing": "Performance testing",
              "Compatibility Testing": "Compatibility Testing"
            };

            const selectedTestingType = getDropdownValue("Type of Testing");
            for (const [key, label] of Object.entries(testingTypeMap)) {
              if (selectedTestingType === key && !currentLabels.includes(label)) {
                labelsToAdd.push(label);
              } else if (selectedTestingType !== key && currentLabels.includes(label)) {
                labelsToRemove.push(label);
              }
            }

            // Execution context labels
            const selectedContext = getDropdownValue("Where is this test run\?");
            if (selectedContext === "Local" && !currentLabels.includes("local")) {
              labelsToAdd.push("local");
            } else if (selectedContext !== "Local" && currentLabels.includes("local")) {
              labelsToRemove.push("local");
            }
            if (selectedContext === "Production" && !currentLabels.includes("production")) {
              labelsToAdd.push("production");
            } else if (selectedContext !== "Production" && currentLabels.includes("production")) {
              labelsToRemove.push("production");
            }

            // Section of the website
            const sectionLabels = [
              "Misiunea Noastra",
              "Cum poti ajuta tu?",
              "De ce sa ajuti?",
              "Echipa",
              "Povesti de succes",
              "Footer",
              "Header"
            ];
            const selectedSection = getDropdownValue("Section of the Website");
            for (const section of sectionLabels) {
              if (selectedSection === section && !currentLabels.includes(section)) {
                labelsToAdd.push(section);
              } else if (selectedSection !== section && currentLabels.includes(section)) {
                labelsToRemove.push(section);
              }
            }

            // Cross testing checkboxes
            if (isCheckboxChecked("Cross-OS testing is required") && !currentLabels.includes("Cross-OS")) {
              labelsToAdd.push("Cross-OS");
            } else if (!isCheckboxChecked("Cross-OS testing is required") && currentLabels.includes("Cross-OS")) {
              labelsToRemove.push("Cross-OS");
            }

            if (isCheckboxChecked("Cross-browser testing is required") && !currentLabels.includes("Cross-browser")) {
              labelsToAdd.push("Cross-browser");
            } else if (!isCheckboxChecked("Cross-browser testing is required") && currentLabels.includes("Cross-browser")) {
              labelsToRemove.push("Cross-browser");
            }

            // Bug found checkbox
            if (isCheckboxChecked("Bug was discovered during test execution") && !currentLabels.includes("Bug(s) found")) {
              labelsToAdd.push("Bug(s) found");
            } else if (!isCheckboxChecked("Bug was discovered during test execution") && currentLabels.includes("Bug(s) found")) {
              labelsToRemove.push("Bug(s) found");
            }

            // Add new labels
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: labelsToAdd
              });
            }

            // Remove unchecked or deselected labels
            for (const label of labelsToRemove) {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number,
                name: label
              }).catch(err => {
                console.log(`Label '${label}' could not be removed:`, err.message);
              });
            }
