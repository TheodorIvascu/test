name: Auto Label Test Cases

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

jobs:
  test-case-labeling:
    runs-on: ubuntu-latest
    steps:
      - name: Apply dynamic labels based on test case form
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || "";
            const currentLabels = issue.labels.map(label => label.name);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = issue.number;

            let labelsToAdd = [];
            let labelsToRemove = [];

            // Type of Testing labels
            const testingTypeMap = {
              "Navigation": "Navigation",
              "Content Testing": "Content Testing",
              "GUI and Usability": "GUI and Usability",
              "Performance Testing": "Performance testing",
              "Compatibility Testing": "Compatibility Testing"
            };

            const selectedTestingType = Object.keys(testingTypeMap).find(key => body.includes(`- ${key}`));

            for (const [key, label] of Object.entries(testingTypeMap)) {
              if (selectedTestingType === key && !currentLabels.includes(label)) {
                labelsToAdd.push(label);
              } else if (selectedTestingType !== key && currentLabels.includes(label)) {
                labelsToRemove.push(label);
              }
            }

            // Execution context labels
            const isLocal = body.includes("- Local");
            const isProduction = body.includes("- Production");

            if (isLocal && !currentLabels.includes("local")) {
              labelsToAdd.push("local");
            } else if (!isLocal && currentLabels.includes("local")) {
              labelsToRemove.push("local");
            }

            if (isProduction && !currentLabels.includes("production")) {
              labelsToAdd.push("production");
            } else if (!isProduction && currentLabels.includes("production")) {
              labelsToRemove.push("production");
            }

            // Section of the website
            const sectionLabels = [
              "Misiunea Noastra",
              "Cum poti ajuta tu?",
              "De ce sa ajuti?",
              "Echipa",
              "Povesti de succes",
              "Footer"
            ];

            for (const section of sectionLabels) {
              if (body.includes(`- ${section}`) && !currentLabels.includes(section)) {
                labelsToAdd.push(section);
              } else if (!body.includes(`- ${section}`) && currentLabels.includes(section)) {
                labelsToRemove.push(section);
              }
            }

            // Cross testing checkboxes
            if (body.includes("- [x] Cross-OS testing is required") && !currentLabels.includes("Cross-OS")) {
              labelsToAdd.push("Cross-OS");
            } else if (!body.includes("- [x] Cross-OS testing is required") && currentLabels.includes("Cross-OS")) {
              labelsToRemove.push("Cross-OS");
            }

            if (body.includes("- [x] Cross-browser testing is required") && !currentLabels.includes("Cross-browser")) {
              labelsToAdd.push("Cross-browser");
            } else if (!body.includes("- [x] Cross-browser testing is required") && currentLabels.includes("Cross-browser")) {
              labelsToRemove.push("Cross-browser");
            }

            // Bug found checkbox
            if (body.includes("- [x] Bug was discovered during test execution") && !currentLabels.includes("Bug(s) found")) {
              labelsToAdd.push("Bug(s) found");
            } else if (!body.includes("- [x] Bug was discovered during test execution") && currentLabels.includes("Bug(s) found")) {
              labelsToRemove.push("Bug(s) found");
            }

            // Add new labels
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: labelsToAdd
              });
            }

            // Remove unchecked or deselected labels
            for (const label of labelsToRemove) {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number,
                name: label
              }).catch(err => {
                console.log(`Label '${label}' could not be removed:`, err.message);
              });
            }
